---
title: "GENIE BPC Bladder"
author: "Alex Paynter"
date: "May 2023"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: paper
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, include = F,
                      warning = F, message = F,
                      fig.width = 7, fig.height = 5)
```


<style type="text/css">
.main-container {
  max-width: 1000px !important;
  margin: auto;
}
</style>



```{r}
library(purrr); library(fs); library(here);
purrr::walk(.x = fs::dir_ls(here('R')), .f = source)
```


```{r, set_gtsummary_theme}
theme_gtsummary_compact(font_size = 12)
theme_gtsummary_language("en", big.mark = "") 
flextable::set_flextable_defaults(
  font.size = 10,
  text.align = "left"
)
```


```{r, warning = T}
read_wrap <- function(p) {
  read_rds(
    file = here("data", 'cohort', paste0(p, '.rds'))
  )
}

dft_pt <- read_wrap("pt")
dft_ca_ind <- read_wrap("ca_ind")
dft_img <- read_wrap("img")
dft_med_onc <- read_wrap("med_onc")
dft_path <- read_wrap("path")
dft_reg <- read_wrap("reg")
# dft_tm <- read_wrap("tm_level_dataset.csv")
dft_cpt <- read_wrap("cpt")

n_bladder_cohort <- dft_ca_ind %>% nrow()

```

```{r, load_derived_data}
dft_drug <- read_rds(file = here("data", 'cohort', 'drug.rds'))
# The drug data is already filtered down to index cancer cases. 
# We don't have do the step done for regimens above.

read_wrap_dmet <- read_wrap <- function(p) {
  read_rds(
    file = here("data", 'dmet', p)
  )
}

dft_pt_dmet <- read_wrap_dmet("pt_dmet.rds")
dft_ca_ind_dmet <- read_wrap_dmet("ca_ind_dmet.rds")
dft_reg_dmet_s <- read_wrap_dmet("reg_start_gte_dmet.rds")
```


```{r, demo_data_manipulation, include = F}
dft_pt_baseline_sub <- dft_pt %>%
  mutate(
    `Race (primary)` = format_ptlevel_naaccr_race_code_primary(
      naaccr_race_code_primary
    ),
    `Ethnicity` = format_ptlevel_naaccr_ethnicity_code(
      naaccr_ethnicity_code,
    ),
    `Sex at birth` = factor(naaccr_sex_code)
  ) %>%
  select(record_id, 
         Institution = institution,
         `Race (primary)`,
         `Ethnicity`,
         `Sex at birth`,
         birth_year)

dft_ca_ind_baseline_sub <- dft_ca_ind %>%
  mutate(
    ca_dx_how = format_ca_dx_how(ca_dx_how),
    ca_hist_adeno_squamous = format_ca_hist_adeno_squamous(ca_hist_adeno_squamous),
    stage_dx = format_stage_dx(stage_dx),
    ca_dmets_yn = format_ca_dmets_yn(ca_dmets_yn),
    ca_path_n_stage = format_ca_path_n_stage(ca_path_n_stage)
  ) %>%
  select(
    record_id,
    `Age at dx (years)` = dob_ca_dx_yrs,
    `Stage at dx` = stage_dx,
    `Source of dx date` = ca_dx_how,
    `Mets among Stage IV` = ca_dmets_yn,
    # Update May 5:  Removed histology (unimportant)
    # `Histology` = ca_hist_adeno_squamous, # at dx?
    `Pathologic N Stage` = ca_path_n_stage # describes spread to lymph nodes
  ) 

dft_med_onc_dx <- augment_med_onc_imputed_ecog(dft_med_onc)

dft_med_onc_dx %<>%
  filter(md_ecog_imputed != "Not documented in note") %>%
  mutate(md_ecog_imputed = format_md_ecog(md_ecog_imputed)) %>%
  group_by(record_id) %>%
  filter(dx_md_visit_days < 30 & dx_md_visit_days > -180) %>%
  mutate(abs_days = abs(dx_md_visit_days)) %>%
  arrange(abs_days) %>% 
  slice(1) %>%
  ungroup(.) %>%
  select(
    record_id, 
    `ECOG (or Karnofsky)` =  md_ecog_imputed,
    `ECOG scale source` = md_ecog_imp_source,
  )

dft_demo <- full_join(
  dft_pt_baseline_sub,
  dft_ca_ind_baseline_sub,
  by = "record_id"
) %>%
  full_join(
    .,
    dft_med_onc_dx,
    by = "record_id"
  )


# age_dx is not an integer in this cohort, so this should be more exact.
dft_demo %<>% 
  mutate(
    `Year of birth` = birth_year,
    `Year of diagnosis` = round(birth_year + `Age at dx (years)`)
  ) %>%
  select(-birth_year) %>%
  relocate(`Year of birth`, `Year of diagnosis`,
           .before = `Age at dx (years)`) 
```


## Content

### R1.1a: Characteristics at dx

Table of characteristics at diagnosis.  A few notes:

- If Karnofsky scale is reported, we convert that to ECOG and use it in this table.
- ECOG scores are only reported if captured near diagnosis/baseline.  I defined this (arbitrarily) as any measurement up to 180 days before and 30 days after diagnosis.  

```{r, tab_r1_1a, include = T}
dft_demo %>%
  select(-record_id) %>%
  gtsummary::tbl_summary(
    data = .,
    digits = list(
      `Year of birth` ~ 0,
      `Year of diagnosis` ~ 0
    )
  ) 
```

**Comment:** "Mets among Stage IV" and "Stage at dx" could be combined into one classification scheme (just dividing the Stage IV category further).  The main disadvantage of doing this is deviating from clear mapping to PRISSMM.

### R1.1b: Characteristics at dx (by site)

The previous table, broken down by site.

```{r, tab_r1_1b, include = T}
dft_demo %>%
  select(-record_id) %>%
  gtsummary::tbl_summary(
    data = ., 
    digits = list(
      `Year of birth` ~ 0,
      `Year of diagnosis` ~ 0
    ),
    by = Institution
  ) 
```

**Observation:** The only site with KPS scores available to convert to ECOG was MSK.  While this table only shows information near diagnosis, this is generally the case that MSK is the only site with subtantial KPS reporting.





```{r}
dft_timing <- make_grand_timing_df(
  pt_dat = dft_pt,
  ca_ind_dat = dft_ca_ind,
  cpt_dat = dft_cpt,
  reg_dat = dft_reg
)

dft_timing %<>% 
  mutate(tt_seq_first_reg_yrs = tt_seq_dx_yrs - tt_first_reg_dx_yrs)

dft_timing_long <- dft_timing %>% 
  select(record_id, ca_seq, matches("^tt_")) %>%
  select(-tt_dx_dob_yrs) %>%
  pivot_longer(
    cols = matches("^tt_"),
    names_to = "interval",
    values_to = "years"
  ) %>%
  mutate(
    interval = beautify_strings(interval, 
                                dict = dict_timing_vars)) 

vec_origin_levs <- c("Diagnosis", "First Regimen", "Metastasis")

dft_timing_long %<>% 
  mutate(
    origin = case_when(
      str_detect(interval, "\\(from dx\\)$") ~ vec_origin_levs[1],
      str_detect(interval, "\\(from first regimen\\)$") ~ vec_origin_levs[2],
      str_detect(interval, "\\(from dmet\\)$") ~ vec_origin_levs[3],
    ),
    origin = factor(origin, levels = vec_origin_levs)
  )

gg_timing_dist_all <- plot_timing_intervals(dat = dft_timing_long)

gg_timing_ecdf_all <- plot_timing_ecdf(dft_timing_long)

gg_timing_comb_all <- cowplot::plot_grid(
  (gg_timing_dist_all + labs(title = "Density")),
  (gg_timing_ecdf_all + labs(title = "eCDF")),
  nrow = 1,
  rel_widths = c(0.7, 0.3)
)

```
  
### R1.3a: Event timing (whole cohort)

The following plots show five time intervals in the entire cohort:

1. Time (years) from diagnosis to the start of the first regimen.
2. Time (years) from diagnosis to the first next generation sequencing test **report date**.
3. Time (years) from first regimen to the first NGS report date.
4. Time (years) from diagnosis to the first note of distant metastasis.  For those diagnosed at Stage IV, this implies a time of zero years.
5. Time (years) that the participant was followed for survival.  Follow-up ends with censoring or death.

On the left violin plots are shown, which approximate the density of observations (similar to a histogram).  Summary statistics are also shown in the top right of these plots.  At right, similar information is shown in an empirical cumulative distribution plot.  An eCDF shows the proportion of the cohort (Y) with a value less than or equal to each duration in years (X).

```{r, include = T, fig.height = 7.5}
gg_timing_comb_all
```





```{r}
# Here we'll use the dmet filtered data for everything except for 
#   the NGS test.  That is, only regimens which were started after
#   distant metastasis, only people who had dmet, etc.
dft_timing_dmet <- make_grand_timing_df_dmet(
  pt_dat = dft_pt_dmet,
  ca_ind_dat = dft_ca_ind_dmet,
  cpt_dat = dft_cpt,
  reg_dat = dft_reg_dmet_s
)

dft_timing_dmet_long <- dft_timing_dmet %>% 
  select(record_id, ca_seq, matches("^tt_")) %>%
  select(-tt_dmet_dob_yrs) %>%
  pivot_longer(
    cols = matches("^tt_"),
    names_to = "interval",
    values_to = "years"
  ) %>%
  mutate(
    interval = beautify_strings(
      interval, 
      dict = dict_timing_vars_dmet
    )
  ) 

vec_origin_levs <- c("Diagnosis", "First Regimen", "Metastasis")

dft_timing_dmet_long %<>% 
  mutate(
    origin = case_when(
      str_detect(interval, "\\(from dx\\)$") ~ vec_origin_levs[1],
      str_detect(interval, "\\(from first regimen\\)$") ~ vec_origin_levs[2],
      str_detect(interval, "\\(from dmet\\)$") ~ vec_origin_levs[3],
    ),
    origin = factor(origin, levels = vec_origin_levs)
  )

gg_timing_dmet_dist_all <- plot_timing_intervals(dat = dft_timing_dmet_long) 
gg_timing_dmet_ecdf_all <- plot_timing_ecdf(dft_timing_dmet_long)

gg_timing_dmet_comb_all <- cowplot::plot_grid(
  (gg_timing_dmet_dist_all + labs(title = "Density")),
  (gg_timing_dmet_ecdf_all + labs(title = "eCDF")),
  nrow = 1,
  rel_widths = c(0.7, 0.3)
)
```



### R1.3b: Event timing (from dmet)

The following plot is similar to the previous, except that times are indexed from the diagnosis of distant metastasis.  The cohort includes only those who were diagnosed with a metastasis at some point in followup.  These are the events shown:

1. First NGS report date relative to the diagnosis of distant metastasis (years).
2. First **post-metastasis** regimen start date, relative to the diagnosis of distant metastasis.  To be clear, regimens continued into the metastatic state are not counted here (open to change on this).
3. Progression or censoring time relative to distant metastasis diagnosis.
4. Survival or censoring time relative to distant metastasis.

```{r, print_dmet_event_timing, include = T, fig.height = 6}
gg_timing_dmet_comb_all
```






```{r}
dft_count_all <- make_obs_count_df(
  med_onc_dat = dft_med_onc,
  img_dat = dft_img,
  reg_dat = dft_reg,
  ca_ind_dat = dft_ca_ind
)

obs_type_levs <- c("Med Onc Notes",
                   "Regimens",
                   "Total Scans",
                   "CT Scan",
                   "MRI Scan",
                   "PET or PET-CT")
                   
dft_count_long <- dft_count_all %>%
  select(record_id, 
         n_med_onc, 
         n_scan_ct, 
         n_scan_mri, 
         n_scan_pet_or_pet_ct,
         n_scan_total,
         n_regimens) %>%
  pivot_longer(cols = -record_id,
               names_to = "type",
               values_to = "n") %>%
  mutate(
    type_f = case_when(
      type %in% "n_med_onc" ~ obs_type_levs[1],
      type %in% "n_regimens" ~ obs_type_levs[2],
      type %in% "n_scan_total" ~ obs_type_levs[3],
      type %in% "n_scan_ct" ~ obs_type_levs[4],
      type %in% "n_scan_mri" ~ obs_type_levs[5],
      type %in% "n_scan_pet_or_pet_ct" ~ obs_type_levs[6]
    ),
    type_f = factor(type_f, levels = obs_type_levs)
  )

dft_count_quantiles <- dft_count_long %>%
  nest(.by = type_f) %>%
  mutate(res = purrr::map(.f = get_quantile_df,
                          .x = data,
                          var = "n")
  ) %>%
  select(type_f, res) %>%
  unnest(res) 

gg_count_ecdf <- ggplot(data = dft_count_long,
                        aes(x = n)) + 
  stat_ecdf(color = '#4477AA') + 
  geom_text_repel(data = dft_count_quantiles,
                  # yes, this is screwed up:
                  aes(x = y, y = n, label = y),
                  hjust = 0, nudge_x = 8, size = 2.5,
                  direction = "x",
                  segment.size = 0.15
  ) + 
  theme_bw() +
  facet_wrap(vars(type_f), scales = "free", nrow = 2) + 
  scale_y_continuous(
    name = "Cohort fraction",
    breaks = c(0, .5, 1),
    labels = paste0(c(0, .5, 1)*100, "%")
  ) + 
  theme(
    strip.text = element_text(hjust = 0)
  )


gg_count_hist_quan <- plot_count_hist_quan(
  dat = dft_count_long,
)



```

### R1.4a: Observations, histogram

The following plot shows the number of people with X observations in our cohort.  The regimens are limited to only those for the index cancer (the other types of observations have no such designation).

```{r, print_count_hist, include = T}
gg_count_hist_quan
```

### R1.4b: Observations, eCDF

Histograms are likely to be better understood by our clinical audience.  The following empirical cumulative distribution plot shows the same data in a way which might be appreciated by readers with computational backgrounds.

```{r, print_count_ecdf, include = T}
gg_count_ecdf
```






```{r create_count_table, include = F}
dfp_obs_count <- dft_count_all %>%
  select(
    Regimens = n_regimens,
    `MedOnc Notes` = n_med_onc,
    `CT` = n_scan_ct,
    `MRI` = n_scan_mri,
    `Bone Scans` = n_scan_bone,
    `PET or PET-CT` = n_scan_pet_or_pet_ct,
    `Total scans` = n_scan_total
  ) %>% 
  gtsummary::tbl_summary(data = ., digits = everything() ~ 0) %>%
  modify_header(
    label = '**Observation Type**'
  )
```

### R1.4c: Observations, table

Simplest representation of the number of observations:  A table with median, first quartile, third quartile.

```{r, include = T}
dfp_obs_count
```










```{r}
dft_ca_ind %>%
  select(contains("abdomen"))

vec_met_loc <- c("abdomen", "bone", "brain", "breast", "extremity",
                  "head_neck", "liver", "pelvis", "thorax")
vec_met_regex <- paste(vec_met_loc, collapse = "|")

dft_met_loc <- dft_ca_ind %>% 
  # variables that describe distant metastasis at/after dx.
  select(
    record_id,
    matches(glue("^dmets_({vec_met_regex})")),
    matches("^dx_to_dmets_.+_yrs$")
  ) 

dft_met_loc %<>%
  pivot_longer(
    cols = -record_id,
    names_to = "var",
    values_to = "value"
  ) %>%
  mutate(
    met_loc = stringr::str_extract(var, vec_met_regex),
    var = if_else(str_detect(var, "yrs"),
                   "dx_to_dmet_yrs",
                   "had_met")
  ) %>%
  pivot_wider(
    names_from = "var",
    values_from = "value"
  )

dft_met_loc %<>% 
  mutate(
    at_dx = case_when(
      had_met %in% 1 & dx_to_dmet_yrs %in% 0 ~ 1,
      had_met %in% 1 & !is.na(dx_to_dmet_yrs) ~ 0,
      T ~ NA_real_
    )
  )

dft_met_loc %<>%
  mutate(
    met_loc = stringr::str_replace(met_loc, "dmets_", ""),
    met_loc = stringr::str_replace(met_loc, "_", "+"),
    met_loc = stringr::str_to_title(met_loc)
  )

dft_met_sum_simple <- dft_met_loc %>%
  group_by(met_loc, at_dx) %>%
  summarize(
    n = sum(had_met, na.rm = T),
    .groups= "drop"
  ) %>%
  filter(!is.na(at_dx)) %>%
  mutate(
    at_dx = if_else(at_dx %in% 1,
                    "at_dx",
                    "post_dx")
  ) %>%
  pivot_wider(
    names_from = at_dx,
    values_from = n
  ) %>%
  mutate(
    across(
      .cols = -met_loc,
      .fns = \(x){ if_else(is.na(x), 0, x) }
    )
  ) %>%
  mutate(
    Anytime = at_dx + post_dx
  ) 

dft_met_sum_simple %<>%
  mutate(
    across(
      .cols = -met_loc,
      # no idea why glue is failing here but it is: 
      .fns = (function(x) 
        paste0(x, " (", form_f((x/n_bladder_cohort)*100), "%)")
      )
    )
  )

dft_met_sum_simple %<>%
  select(
    Location = met_loc,
    `At dx` = at_dx,
    `Post dx` = post_dx,
    Anytime
  )
```

### R1.6a: Metastasis location

The following table counts the number of participants who had a metastasis at diagnosis,

```{r, include = T}
dft_met_sum_simple %>%
  flextable(.) %>%
  flextable::theme_booktabs(.) %>%
  autofit(.)
```






```{r}
dft_met_loc_co <- dft_met_loc %>%
  select(record_id, met_loc, had_met) %>%
  pivot_wider(
    names_from = met_loc,
    values_from = had_met
  ) 

upset_met_loc <- dft_met_loc %>%
  select(record_id, met_loc, had_met) %>%
  pivot_wider(
    names_from = met_loc,
    values_from = had_met
  )  %>%
  as.data.frame(.) %>%
  UpSetR::upset(
    data = .,
    order.by = "freq",
    mainbar.y.label = "Participants with combination",
    nsets = 15,
    nintersects = 50,
    set_size.show = T
  )
```


### R1.6b: Co-occurrence of metastatic locations

The following upset plot shows the combinations of metastatic sites, ordered by the number of people with that combination.  The metastastases here are at any point over the followup period, so they may occur at different times.

```{r, include = T}
upset_met_loc
```

**Comment:** To me this plot is overwhelming.  It may be better to show plots that show the co-occurence with <X> metatstatic site.  For example, the upper plot above shows






```{r}
gg_met_loc_timing <- dft_met_loc %>%
  select(
    record_id, met_loc, dx_to_dmet_yrs
  ) %>%
  filter(met_loc != "Breast") %>% # too few.
  mutate(flat_color = "1") %>%
  mutate(met_loc = forcats::fct_inorder(met_loc)) %>%
  plot_timing_intervals(
    time_var = "dx_to_dmet_yrs",
    time_var_lab = "Years from dx to dmet",
    facet_var = "met_loc",
    color_var = "flat_color",
    facet_cols = 2
  )

```

### R1.6c: Timing of metastasis by site

As a first pass, I am re-using my function for timing intervals, so some of these summary statistics (e.g. non-negative if observed) don't make sense.  We can optimize the plot if it's considered for manuscript inclusion.

```{r, include = T, fig.height = 8}
gg_met_loc_timing
```









```{r}
set.seed(2398) # color sampling below.

dft_drug %>% 
  count(record_id, drug, sort = T) %>%
  count(drug)

dft_top_drugs <- dft_drug %>% 
  count(record_id, drug, sort = T) %>%
  count(drug) %>%
  arrange(desc(n)) %>%
  head(10)

dft_top_drugs %<>%
  mutate(drug = str_replace(drug, "\\(.*\\)", ""))


gg_top_drugs <- plot_drug_prop(
  drug_dat = dft_top_drugs,
  cohort_n = n_bladder_cohort,
  sample(viridisLite::magma(n = 10, begin = 0.2, end = 0.8)),
  plot_title = glue("Drugs started any time (n={n_bladder_cohort})")
)


# Now repeat the calculation above for CRPC regimens only.

dft_dmet_block <- make_dmet_status_block(dft_ca_ind)
  
n_bladder_dmet <- dft_dmet_block %>% 
  filter(dmet_status %in% "Distant Metastasis") %>%
  nrow

dft_drug_dmet <- dft_dmet_block %>%
  filter(dmet_status %in% "Distant Metastasis") %>%
  mutate(dmet_days = dx_block_start * 365.25) %>%
  select(record_id, dmet_days) %>%
  inner_join(
    dft_drug, 
    ., 
    by = "record_id",
    relationship = "many-to-one"
  )

dft_drug_dmet %<>% 
  # dx_drug_start_int is the number of days from dx to start of drug.
  filter(dx_drug_start_int >= dmet_days)

# Same processing from here:
dfp_top_drugs_dmet <- dft_drug_dmet %>%
  group_by(record_id, drug) %>%
  summarize(observed = 1, .groups = "drop") %>%
  group_by(drug) %>%
  summarize(n = sum(observed)) %>%
  arrange(desc(n)) %>%
  head(10) %>%
  mutate(drug = str_replace(drug, "\\(.*\\)", ""))

gg_top_drugs_dmet <- plot_drug_prop(
  drug_dat = dfp_top_drugs_dmet,
  cohort_n = n_bladder_dmet,
  pal = sample(viridisLite::viridis(n = 10, begin = 0.2, end = 0.8)),
  plot_title = glue("Drugs started in metastatic setting (n={n_bladder_dmet})")
)

gg_top_drug_comb <- cowplot::plot_grid(
  gg_top_drugs, gg_top_drugs_dmet,
  ncol = 1
)




  
```

### R2.1a: Drug regimens

The following table shows the proportion of participants who were exposed to each drug at any time during followup.  Only regimens associated with the index cancer are considered, and only the top 10 most used drugs are shown.

```{r, output_top_drug_plot, include = T, fig.height = 6, fig.width = 7}
gg_top_drug_comb
```





```{r}
dft_sun_reg_all <- make_sunburst_input(
  dat = dft_reg,
  var = "regimen_drugs",
  order_var = "regimen_number",
  max_depth = 3
)
```

### R2.2a: Drug regimens (sunburst)

The following plot (a "sunburst" plot) shows the regimens used by the cohort which were associated with an index cancer.  The innermost ring is the first drug regimen reported after diagnosis.  The second ring shows the second drug regimen used after diagnosis, etc.

```{r, include = T}
sun_wrap(dft_sun_reg_all, seed = 238)
```

Places to go from here to get a more tractable display:

- Categorize the drugs into a few categories.
- Look at the ordering of specific drugs of interest.
- Examine the drugs used on/after an event of interest (distant metastasis, for example).


```{r}
dft_sun_reg_dmet <- make_sunburst_input(
  dat = dft_reg_dmet_s,
  var = "regimen_drugs",
  order_var = "regimen_number",
  max_depth = 3
)
```


### R2.2b: Drug regimens (metastatic setting)

```{r, include = T}
sun_wrap(dft_sun_reg_dmet, seed = 238)
```





















## Notes

### Issues

#### Stage IV vs Metastatic at diagnosis

Just a note:  The variable `ca_dmets_yn` is only populated for participants who are stage IV at diagnosis.  Here is a cross tabulation of this variable with `stage_dx` (columns):

```{r, include = T}
dft_ca_ind %>% tabyl(ca_dmets_yn, stage_dx_iv)
```


#### Pathologic N stage

On Sept 25, 2023 we discussed pathologic N stage and that it may only make sense for participants who have had surgery.  The sticking point here is I don't know if we have that information in our dataset.  If anyone with the appropriate clinical knowledge would be willing to search that data guide that may help.

Additionally, here is what the data guide tells us for the variable used to report Pathologic N stage (`ca_path_n_stage`):

> Description
> - Curated pathologic N stage
> - N describes spread of cancer to nearby lymph nodes • Populated only if:
> - Cancer diagnosis is curated. This field is blank for cancer diagnoses obtained from the tumor registry.
> - Cancers was not diagnosed at stage IV ([ca_stage_iv] = “No”).

It may be that this is not important to report - I don't have a great reason for having included it in the first place.  There are loads of other choices for staging variables.

### Todos

- Add swimmer plot.



```{r, output_for_clinicians, eval = F}
# This needs to be manually run, it's just output files 
# for the unique regimens and drugs.
reg_sum <- dft_reg %>%
  select(record_id, ca_seq, regimen_drugs) %>%
  group_by(regimen_drugs) %>%
  summarize(
    n_reg = n(),
    n_pts = length(unique(record_id))
  )

drug_sum <- dft_reg %>%
  select(record_id, ca_seq, regimen_number, matches("^drugs_drug_")) %>%
  pivot_longer(
    cols = matches("^drugs_drug_"),
    names_to = "drug_number",
    values_to = "drug"
  ) %>%
  filter(!is.na(drug)) %>%
  group_by(drug) %>%
  summarize(
    n_uses = n(),
    n_pts = length(unique(record_id))
  ) %>%
  # just a start!
  mutate(
    class = case_when(
      str_detect(drug, "Cisplatin") ~ "platinum-based chemo",
      str_detect(drug, "Paclitaxel") ~ "taxane",
      T ~ NA_character_
    )
  )
      

readr::write_csv(
  x = reg_sum,
  file = here('output', 'other', 'unique_regimens.csv'),
  na = ''
)

readr::write_csv(
  x = drug_sum,
  file = here('output', 'other', 'unique_drugs.csv'),
  na = ''
)
  
```

